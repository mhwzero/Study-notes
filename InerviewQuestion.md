# <center>面试题</center>
[toc]
## 1、JVM运行时数据区描述一下及每个区的作用
|序号|区域名称|共享|作用|异常|备注|
|:---|:---:|:---:|:---:|:---:|---:|
|1|程序计数器|线程私有|记录当前线程锁执行的字节码行号指示器。|Java虚拟机规范中唯一一个没有规定OutOfMemoryError(内存不足错误)的区域。|--|
|2|Java虚拟机|线程私有|存放局部变量表、操作数据栈、动态链接、方法出口等信息。|栈深大于允许的最大深度，抛出StackOverflowError(栈溢出错误)。|常说的“栈”说的就是Java虚拟机栈，或者是Java虚拟机栈中的局部变量表。|
|3|本地方法栈|线程私有|和Java虚拟机栈类似，不过是为JVM用到的Native方法服务。|同上||
|4|Java堆|线程共享|存放实例化数据。|内存不足时，抛出OutOfMemoryError(内存不足错误)。|通过-Xmx和-Xms控制大小。GC的主要管理对象。|
|5|方法区|线程共享|存放类信息（版本、字段、方法、接口等）、常量、静态变量、即时编译后的代码等数据。|内存不足时，抛出OutOfMemoryError(内存不足错误)。|--|
|6|运行时常量池|线程共享|存放编译期生成的各种字面量和符号引用。|内存不足时，抛出OutOfMemoryError(内存不足错误)。|属于“方法区”的一部分。|
|7|直接内存|--|如NIO可以使用Native函数库直接分配堆外内存，该内存受计算机内存限制。|内存不足时，抛出OutOfMemoryError(内存不足错误)。|不是JVM运行时数据区的一部分，也不是JVM虚拟机规范中定义的内存区域。但这部分内存也被频繁的使用。所以放到一起。

[JVM运行时数据区描述一下及每个区的作用](https://cloud.tencent.com/developer/article/1793351)
## 2、静态变量与实例变量区别？
```
静态变量前要加上关键字static，实例变量则不会。

实例变量是属于某个对象的属性，必须创建了实例对象，其中的实例变量才会分配空间，才能使用这个实例变量。
静态变量不属于任何的实例对象，而是属于类，也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，就会被分配空间。
总之就是，静态变量不需要创建任何的对象就可以直接使用，而实例变量需要先创建实例对象才能被使用。
```
## 3、String类的常用方法有哪些?
```
1、和长度有关：

int length() 得到一个字符串的字符个数
2、和数组有关：


byte[] getByte() ) 将一个字符串转换成字节数组
char[] toCharArray() 将一个字符串转换成字符数组
String split(String) 将一个字符串按照指定内容劈开

3、和判断有关：


boolean equals() 判断两个字符串的内容是否一样
boolean equalsIsIgnoreCase(String) 忽略太小写的比较两个字符串的内容是否一样
boolean contains(String) 判断一个字符串里面是否包含指定的内容
boolean startsWith(String) 判断一个字符串是否以指定的内容开头
boolean endsWith(String) 判断一个字符串是否以指定的内容结尾

4、和改变内容有关：


String toUpperCase() 将一个字符串全部转换成大写
String toLowerCase() 将一个字符串全部转换成小写
String replace(String,String) 将某个内容全部替换成指定内容
String replaceAll(String,String) 将某个内容全部替换成指定内容，支持正则
String repalceFirst(String,String) 将第一次出现的某个内容替换成指定的内容
String substring(int) 从指定下标开始一直截取到字符串的最后
String substring(int,int) 从下标x截取到下标y-1对应的元素
String trim() 去除一个字符串的前后空格

5、和位置有关：


char charAt(int) 得到指定下标位置对应的字符
int indexOf(String) 得到指定内容第一次出现的下标
int lastIndexOf(String) 得到指定内容最后一次出现的下标

```
## 4、接口和抽象类的区别是什么？
```
1、最重要的区别是，接口的方法不可以有实现，并且是绝对的抽象方法。抽象类可以有实例方法用来实现默认行为。
2、接口中的变量申明默认是final, 而抽象类中变量申明可以是非final。
3、接口中的成员默认是public修饰，而抽象类中成员可以是private, protected等等。
4、接口通过关键字implements被其他类实现，而抽象类则是通过extends关键字被其他类扩展.
5、接口可以扩展（extends）另外一个/或多個接口，抽象类可以扩展（extends）另一个Java类并(或)实现（implements）多个Java接口.
6、Java类可以实现多个接口但是只能扩展一个抽象类.
7、接口是绝对抽象而且无法实例化，抽象类也无法实例化但是如果类中有main()方法是可以被调用的。
8、与抽象类相比，接口更慢，因为它需要额外的间接寻址。
```
## 5、Java 中的 final 关键字有哪些用法
```
当final修饰变量时，被修饰的变量必须被初始化(赋值)，且后续不能修改其值，实质上是常量；
当final修饰方法时，被修饰的方法无法被所在类的子类重写（覆写）；
当final修饰类时，被修饰的类不能被继承，并且final类中的所有成员方法都会被隐式地指定为final方法，但成员变量则不会变。
```
## 6、StringBuffer、StringBuilder的区别是什么？
```

```
## 7、String str = “i” 和String str = new String(“1”)一样吗？
```
因为内存的分配方式不一样。String str="i"的方式，Java 虚拟机会将其分配到常量池中；
而 String str=new String(“i”)方式，则会被分到堆内存中，但进入堆内存的时候会先进入堆常量池中是否有这个常量，
如果没有则将堆常量写入，再写入堆内存中。
```
##8、重载(overload)和重写(override)的区别?
```
方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。
(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。
(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现
```
## 9、Java 中的值传递和引用传递
```
1）、值传递 在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，
这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。

2）、引用传递 引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，
而引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，
也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。

总的来说:
引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象。
```
##10、关于==与equals的区别
```
     ==：一般用于基本数据类型的比较，在引用数据类型中比较的是地址
     equals：一般用于引用数据类型的比较，比较的是内容是否相等。格式为：值1.equals(值2)
注意： instanceof：一般用于类的比较。格式为：变量名 instanceof 类型 
 通俗的理解为：判断关键字左边的变量，是否是右边的类型，放回boolean类型结果
```
## 11、sleep和wait的区别？ 
```
     sleep是让线程休眠，到时间后会继续执行;
     wait是等待，需要唤醒再继续执行，
     
使用方面：
        从使用的角度来看sleep方法是Thread线程类的方法，而wait是Object顶级类的方法。
        sleep可以在任何地方使用，而wait只能在同步方法和同步块中使用。
CPU及锁资源释放:
        sleep、wait调用后都会暂停当前线程并让出CPU的执行时间，但不同的是sleep不会释放当前持有对象的锁资源，到时间后会继续执行，而wait会释放所有的锁并需要notify/notifyAll后重新获取到对象资源后才能继续执行。
        异常捕获方面：
        sleep需要捕获或者抛出异常，而wait/notify/notifyAll则不需要。
```
## 12、请写出你最常见的几个 Runtime Exception？与非运行时异常的区别？
```
常见的 Runtime Exception：
1、NullPointerException － 当调用一个未初始化的引用变量（实际值为null）的实例Field、实例方法时都会引发该异常。
2、ArithmeticException － 算术异常。比如5/0将引发该异常。
3、ArrayIndexOutOfBoundsException：数组索引越界异常。
4、ClassCastException：类型转换异常。
5、IllegalArgumentException：参数非法的异常。

```
## 13、try catch有return，发生异常，走return还是finally
```
1、finally块的语句在try或catch中的return语句执行之后返回之前执行。
2、finally语句块不改变栈中的值y，可改变堆中的值。
y的类型如果是基本类型，其临时存放在栈中，则在finally块里被修改也不影响y，如果是存放在堆中的引用类型则可以。finally块里改变文本字符串也不影响y。
3、finally里的return语句覆盖try或catch中的return语句直接返回。
```
![try catch、return、finally的执行顺序](https://www.cnblogs.com/east7/p/14533249.html)
## 14、Java注解可以加在什么地方？Java自带注解有哪些？哪里有用到注解？
```

```
## 15、什么是双亲委派模型？为什么要使用双亲委派模型
```
双亲委托模型：
当某个特定的类加载器它在接到需要加载类的请求时，这个类会首先查看自己已加载完的类中是否包含这个类，
如果有就返回，没有的话就会把加载的任务交给父类加载器加载，以此递归，父类加载器如果可以完成类加载任务，就返回它，
当父类加载器无法完成这个加载任务时，才会不得已自己去加载。这种机制就叫做双亲委派机制。
```
```
工作机制：
类装载器就是寻找类的字节码文件，并构造出类在JVM内部表示的对象组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤：
1) 装载：查找和导入Class文件;
2) 链接：把类的二进制数据合并到JRE中;
(a)校验：检查载入Class文件数据的正确性;
(b)准备：给类的静态变量分配存储空间;
(c)解析：将符号引用转成直接引用;
3) 初始化：对类的静态变量，静态代码块执行初始化操作
```
```
类加载器的组成:
(1)BootstrapClassLoader 根类加载器
    也被称为引导类加载器，负责Java核心类的加载
    引导类加载器BootstrapClassLoader：
        用C++编写的，是JVM自带的类加载器，
        负责Java平台核心库，用来加载核心类库。该加载器无法直接获取
    比如System,String等。

(2)ExtClassLoader 扩展类加载器
    负责JRE的扩展目录中jar包的加载
    在JDK中JRE的lib目录下ext目录

(3)AppClassLoader 系统类加载器/应用类加载器
    Java语言编写的类加载器，负责加载我们定义的类和第三方jar包中的类。
```
```
为什么要使用双亲委派模型：
1、java虚拟机只会在不同的类的类名相同且加载该类的加载器均相同的情况下才会判定这是一个类。如果没有双亲委派机制，同一个类可能就会被多个类加载器加载，如此类就可能会被识别为两个不同的类，相互赋值时问题就会出现。
2、双亲委派机制能够保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。
3、没有双亲委派模型，让所有类加载器自行加载的话，假如用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，系统就会出现多个不同的Object类，
4、Java类型体系中基础行为就无法保证，应用程序就会变得一片混乱。
```
## 16、浅拷贝和深拷贝区别
```
对于基本类型，深拷贝和浅拷贝都是一样的，都是对原始数据的复制，修改原始数据，不会对复制数据产生影响。
两者的区别，在于对引用属性的复制：
    1、浅拷贝复制引用属性时，仅仅复制指针值，没有复制指向的对象。
    2、深拷贝完整复制一份该属性指向的对象，这样两个对象修改时，互相不产生影响。
注：
    Object.clone()方法属于浅拷贝。
```
## 17、Java内存泄漏
```
OOM：内存溢出，OOP：面向对象，AOP：面向切面
内存泄漏：
        对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着，也就是，
        无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。
        内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。
        在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，
        首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；
        其次，这些对象是无用的，即程序以后不会再使用这些对象。
        如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。
```
## 18、集合类中主要有几种接口
```
Collection(元素集合) 和 Map(键值对集合) 
其中List和Set接口继承了Collection接口，一个是有序元素集合，一个是无序元素集合；
而ArrayList和 LinkedList 实现了List接口，HashSet实现了Set接口，这几个都比较常用； 
HashMap 和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好；
```
## 19、HashSet如何检查重复？
```
当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，
如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。
但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。
如果两者相同，HashSet 就不会让加入操作成功。
```
## 20、HashMap和HashSet区别？
|HashMap|HashSet|
|:---:|:---:|
|实现了Map接口|实现了Set接口|
|存储键值对|仅存储对象|
|调用put()方法向map中添加元素|调用add方法向Set()中添加元素|
|HashMap使用键(key)计算Hashcode|HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两对象不同的话，返回false|
|HashMap相对于HashSet较快，因为它是使用唯一的键获取对象|HashSet较HashMap来说比较慢|
    HashMap相较于HashSet较快，因为它是使用唯一的键获取对象，HashSet较HashMap来说比较慢
## 21、HashMap底层实现原理是什么？
```
在JDK1.8中，对HashMap的底层实现进行了优化，数据结构的存储由数组+链表的方式，变化为数组+链表+红黑树的存储方式，
当链表中的节点数量超过8，且数组元素数量大于等于64的时候，将链表转换为红黑树，目的是为了提高查询速度
```
## 22、Hashtable与HashMap有什么不同之处？
```
HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。

1、HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。
2、HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。
3、另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。
4、由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。
5、HashMap不能保证随着时间的推移Map中的元素次序是不变的。
```
[Hashtable和HashMap的区别](http://www.cnblogs.com/binyue/p/4545550.html)
## 23、红黑树有什么特征？
```
红黑树是由二叉树演变而来，是一个平衡树，是一个非常严格均衡的搜索二叉树
红黑树的特征：
节点分为红色或者黑色。
根节点必为黑色。
叶子节点都为黑色，且为 null。
连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）。
从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点。
新加入到红黑树的节点为红色节点。
```
[红黑树](https://cloud.tencent.com/developer/news/542994)
## 24、字节流和字符流区别？
```
1、字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。
2、字节流默认不使用缓冲区；字符流使用缓冲区。
3、字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出；字符流在操作的时候是使用到缓冲区的。如果字符流不调用close或flush方法，则不会输出任何内容。
4、字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。
5、字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以。

```
## 25、BIO和NIO区别？
```
1、BIO是面向流，只能读或者只能写，阻塞IO；而NIO是面向缓冲区，可以同时进行读写，非阻塞IO
2、NIO以流的方式处理数据，NIO以块的方式处理数据，块IO的效率比流IO高很多。（比如说流IO他是一个流，你必须时刻去接着他，不然一些流就会丢失造成数据丢失，所以处理这个请求的线程就阻塞了他无法去处理别的请求，他必须时刻盯着这个请求防止数据丢失。而块IO就不一样了，线程可以等他的数据全部写入到缓冲区中形成一个数据块然后再去处理他，在这期间该线程可以去处理其他请求）
3、BIO基于字节流和字符流进行操作的，而NIO基于Channel（通道）和Buffer（缓冲区）进行操作的，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道事件，因此使用单个线程就可以监听多个客户端通道
也就是相当于：
BIO：排队打饭
NIO：点餐等待被叫

同步阻塞IO和异步非阻塞IO的概念：
同步阻塞IO：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！
同步非阻塞IO:在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。
```
## 26、创建线程有几种方式？
```
1. Thread类：唯一与线程有关的类
   使用方法：
           继承该类，并重写run方法，这样便创建了一个线程。
           创建该子类对象，并调用start方法启动线程
2. Runnable接口：重写run方法
    使用方法：
            实现 Runnable ，并实现 run 方法，也可以创建一个线程。
            创建该子类对象，并调用start方法启动线程
3. 程池：ExecutorService接口        
4. Callable<V>接口：重写call方法 
```
## 27、线程的状态转换？
```
Java中线程的状态分为6种：
1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3. 阻塞(BLOCKED)：表示线程阻塞于锁。
4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
6. 终止(TERMINATED)：表示该线程已经执行完毕。

```
## 28、start和run的区别？
```
start与run方法的主要区别在于当程序调用start方法，一个新线程将会被创建，并且在run方法中的代码将会在新线程上运行，然而在
你直接调用run方法的时候，程序并不会创建新线程，run方法内部的代码将在当前线程上运行。大多数情况下调用run方法是一个bug或者变成失误。
因为调用者的初衷是调用start方法去开启一个新的线程，这个错误可以被很多静态代码覆盖工具检测出来，比如与fingbugs. 
如果你想要运行需要消耗大量时间的任务，你最好使用start方法，否则在你调用run方法的时候，你的主线程将会被卡住，这是因为，
调用run方法，其实是在调用一个普通的Java方法，是顺序执行的，必须等待run方法体里的内容执行完毕后才能执行别的代码块，而调用start()方法的话，
则是启动一个新线程，等待JVM来调用run()方法体里的内容，所以可能先执行别的代码块而后执行run()方法体。另外一个区别在于，一但一个线程被启动，
你不能重复调用该thread对象的start方法，调用已经启动线程的start方法将会报IllegalStateException异常，  而你却可以重复调用run方法。
```
[start和run的区别？](https://blog.csdn.net/cainiaobulan/article/details/80117021)
## 29、创建线程池的核心参数有哪些？
```

```
## 30、Synchronized作用，Synchronized 和 volatile 的区别
```
Synchronized 和 volatile 的区别：
1、volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2、volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
3、volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
4、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
5、volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
```